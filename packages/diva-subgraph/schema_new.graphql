# Challenge entity captures all the challenges
# submitted by position token holders for a given
# contingent pool
type Challenge @entity {
  id: ID!
  challengedBy: Bytes!
  proposedFinalReferenceValue: BigInt!
  pool: Pool!
}

# Pool entity captures the latest state of a 
# contingent pool. Parameters are set/updated when
# a contingent pool is created, liquidity is added/removed
# and during the settlement process (e.g., when final 
# reference value is set)
type Pool @entity {
  id: ID! # original -> poolId
  floor: BigInt!
  inflection: BigInt!
  cap: BigInt!
  gradient: BigInt!
  collateralBalance: BigInt!
  finalReferenceValue: BigInt!
  capacity: BigInt!
  statusTimestamp: BigInt!
  shortToken: PositionToken!
  payoutShort: BigInt!
  longToken: PositionToken!
  payoutLong: BigInt!
  collateralToken: CollateralToken!
  expiryTime: BigInt!
  dataProvider: Bytes!
  protocolFee: BigInt!
  settlementFee: BigInt!
  statusFinalReferenceValue: String!
  referenceAsset: String!
  supplyShort: BigInt!
  supplyLong: BigInt!
  createdBy: Bytes!
  createdAt: BigInt!
  challenges: [Challenge!] @derivedFrom(field: "pool")
}

# CollateralToken entity captures the collateral tokens
# that are being used as collateral assets when creating
# contingent pools. The collateral token is also the asset
# in which fees are denominated.
type CollateralToken @entity {
  id: ID! # original -> collateral token address
  name: String!
  decimals: Int!
  symbol: String!
  feeRecipients: [FeeRecipientCollateralToken!]
    @derivedFrom(field: "collateralToken")
}

type FeeRecipient @entity {
  id: ID! # feeRecipient address
  collateralTokens: [FeeRecipientCollateralToken!]
    @derivedFrom(field: "feeRecipient")
}

type FeeRecipientCollateralToken @entity {
  id: ID! # Set to `${feeRecipient.id}-${collateralToken.id}`
  feeRecipient: FeeRecipient!
  collateralToken: CollateralToken!
  amount: BigInt!
}

type PositionToken @entity {
  id: ID! # Address
  name: String!
  symbol: String!
  decimals: Int!
  pool: Pool!
  owner: Bytes!
  users: [UserPositionToken!]
    @derivedFrom(field: "positionToken")
}

type TestnetUser @entity {
  id: ID! # UserAddress
  binaryPoolCreated: Boolean!
  linearPoolCreated: Boolean!
  convexPoolCreated: Boolean!
  concavePoolCreated: Boolean!
  liquidityAdded: Boolean!
  liquidityRemoved: Boolean!
  buyLimitOrderCreatedAndFilled: Boolean!
  sellLimitOrderCreatedAndFilled: Boolean!
  buyLimitOrderFilled: Boolean!
  sellLimitOrderFilled: Boolean!
  finalValueReported: Boolean!
  reportedValueChallenged: Boolean!
  positionTokenRedeemed: Boolean!
  feeClaimed: Boolean!
  feeClaimTransferred: Boolean!
  startTime: BigInt!
  endTime: BigInt!
}

type User @entity {
  id: ID! # UserAddress
  positionTokens: [UserPositionToken!]
    @derivedFrom(field: "user")
}

type UserPositionToken @entity {
  id: ID! # Set to `${user.id}-${positionToken.id}`
  user: User!
  positionToken: PositionToken!
  receivedAt: BigInt! # timestamp when user received position token via create pool, add liquidity or trading 
}

type NativeOrderFill @entity {
    # tx hash - order hash - log index
    id: ID!
    orderHash: Bytes!
    maker: Bytes!
    taker: Bytes!
    makerToken: Bytes!
    takerToken: Bytes!
    makerTokenFilledAmount: BigInt!
    takerTokenFilledAmount: BigInt!
    timestamp: BigInt!
}